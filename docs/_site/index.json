{
  "api/KCC.ColliderType.html": {
    "href": "api/KCC.ColliderType.html",
    "title": "Enum ColliderType | KCC",
    "summary": "Enum ColliderType Namespace KCC Assembly KCC.CSharp.dll Collider shape for KCC characters. public enum ColliderType Fields Box = 0 Box shape. Capsule = 1 Capsule shape. Sphere = 2 Sphere shape."
  },
  "api/KCC.GroundState.html": {
    "href": "api/KCC.GroundState.html",
    "title": "Enum GroundState | KCC",
    "summary": "Enum GroundState Namespace KCC Assembly KCC.CSharp.dll Ground state for KCC characters. public enum GroundState Fields Grounded = 1 Character is grounded (standing on valid ground). Ungrounded = 0 Character is not grounded (not touching any valid ground)."
  },
  "api/KCC.IKinematicCharacter.html": {
    "href": "api/KCC.IKinematicCharacter.html",
    "title": "Interface IKinematicCharacter | KCC",
    "summary": "Interface IKinematicCharacter Namespace KCC Assembly KCC.CSharp.dll The required interface for controlling KinematicCharacterController. public interface IKinematicCharacter Methods KinematicAttachedRigidBodyEvent(bool, RigidBody?) Called when the character attaches or detaches itself from a rigidbody. void KinematicAttachedRigidBodyEvent(bool attached, RigidBody? rigidBody) Parameters attached bool True if attaching, False if detaching rigidBody RigidBody Rigidbody being attached to, or being detached from KinematicAttachedRigidBodyUpdate(RigidBody) Called for every tick the character is attached to a rigidbody to move with, may be useful if you wish to rotate the camera along side the rigidbody it is attached to. void KinematicAttachedRigidBodyUpdate(RigidBody rigidBody) Parameters rigidBody RigidBody KinematicCanAttachToRigidBody(RigidBody) Called during the sweep to check if the character can attach to a rigidbody to move with it. bool KinematicCanAttachToRigidBody(RigidBody rigidBody) Parameters rigidBody RigidBody Returns bool True if can attach, False if not KinematicCollision(RayCastHit) Called when the character collides with something during a sweep, this may be useful if you need to have something external react to the collision as the final position of the controller’s collider may not actually end up colliding with whatever it hit at the end of the sweep. void KinematicCollision(RayCastHit hit) Parameters hit RayCastHit KinematicCollisionValid(Collider) Called when the character collides with something during a sweep, this can be used to precisely filter out collisions (eg. teammates). bool KinematicCollisionValid(Collider other) Parameters other Collider Returns bool True if should collide, False if should pass through KinematicGroundProjection(Vector3, Vector3) Called the the character velocity needs to be projected along side the current ground plane during the sweep, the velocity supplied here is the remaining velocity for the tick at the point where this callback is triggered. This is necessary if you wish to move up sloped surfaces without issues. Vector3’s ProjectOnPlane will suffice for modern use. Tip: the KinematicCharacterController supplies the function “GroundTangent” to help with retro style projection where the ground normal does not affect any lateral speed. Vector3 KinematicGroundProjection(Vector3 velocity, Vector3 gravityEulerNormalized) Parameters velocity Vector3 Current velocity gravityEulerNormalized Vector3 Current normalized gravity as euler angles Returns Vector3 Velocity KinematicGroundingEvent(GroundState, RayCastHit?) Called when the character’s ground state changes during a sweep, this may be useful if you wish to implement particle effects upon landing on ground for example. void KinematicGroundingEvent(GroundState groundingState, RayCastHit? hit) Parameters groundingState GroundState The new state hit RayCastHit? Hit from grounding check, null if ungrounding KinematicMoveUpdate(out Vector3, out Quaternion) Called when the simulation needs to know the velocity and orientation for a tick before sweeping movement, the character will attempt to move until the length of the velocity is more or less zero. You may transfer root motion to the system by extracting it from the animation and applying it here. void KinematicMoveUpdate(out Vector3 velocity, out Quaternion orientation) Parameters velocity Vector3 orientation Quaternion KinematicPostUpdate() Called when the controller has done all the movement processing. void KinematicPostUpdate() KinematicRigidBodyInteraction(RigidBodyInteraction) Called during the sweep when the character collides with a rigidbody, may be useful if you wish to have rigidbodies react interactively and you want to handle it yourself. void KinematicRigidBodyInteraction(RigidBodyInteraction rbInteraction) Parameters rbInteraction RigidBodyInteraction KinematicUnstuckEvent(Collider, Vector3, float) Called when the character unstucks itself during a sweep, this may be useful if you want to implement crushers for example. void KinematicUnstuckEvent(Collider collider, Vector3 penetrationDirection, float penetrationDistance) Parameters collider Collider penetrationDirection Vector3 penetrationDistance float"
  },
  "api/KCC.IKinematicMover.html": {
    "href": "api/KCC.IKinematicMover.html",
    "title": "Interface IKinematicMover | KCC",
    "summary": "Interface IKinematicMover Namespace KCC Assembly KCC.CSharp.dll The required interface for controlling KinematicMover. public interface IKinematicMover Methods KinematicUpdate(out Vector3, out Quaternion) Callback to inform the system of the kinematic mover's wished position and orientation. void KinematicUpdate(out Vector3 goalPosition, out Quaternion goalOrientation) Parameters goalPosition Vector3 goalOrientation Quaternion"
  },
  "api/KCC.InterpolationMode.html": {
    "href": "api/KCC.InterpolationMode.html",
    "title": "Enum InterpolationMode | KCC",
    "summary": "Enum InterpolationMode Namespace KCC Assembly KCC.CSharp.dll KCC Interpolation mode. NOTE: This will be removed in the future once Flax is capable of synching event loop with rendering. (waiting for PR to be accepted). public enum InterpolationMode : byte Fields LateUpdate = 0 Interpolation should happen in LateUpdate. Update = 1 Interpolation should happen in Update."
  },
  "api/KCC.KCC.html": {
    "href": "api/KCC.KCC.html",
    "title": "Class KCC | KCC",
    "summary": "Class KCC Namespace KCC Assembly KCC.CSharp.dll public class KCC : GamePlugin Inheritance object Object Plugin GamePlugin KCC Constructors KCC() Initializes a new instance of the FlaxEngine.GamePlugin. public KCC() Properties KCCSettingsInstance KCCSettings instance. public KCCSettings? KCCSettingsInstance { get; } Property Value KCCSettings Methods Deinitialize() Cleanup method called when this plugin is being unloaded or reloaded or engine is closing. public override void Deinitialize() Initialize() Initialization method called when this plugin is loaded to the memory and can be used. public override void Initialize() InterpolationUpdate() Processes per frame interpolation for all KCC Actors, moving them between ther initial and final positions as determined by last KCC simulation executed. public void InterpolationUpdate() OnFixedUpdate() public void OnFixedUpdate() OnLateUpdate() public void OnLateUpdate() OnUpdate() public void OnUpdate() PostSimulationUpdate() Sets up for interpolation after the simulation. All KCC Actors are moved back to their initial position, so that the interpolation appears correct. If interpolation is disabled all KCC Actors are moved to their final position. public void PostSimulationUpdate() PreSimulationUpdate() Saves necessary info for interpolation before the simulation. All KCC Actors are moved to their finalized positions from previous frame, forcing a finish to the interpolation. public void PreSimulationUpdate() Register(KinematicCharacterController) Register a kinematic character to the simulation. public void Register(KinematicCharacterController character) Parameters character KinematicCharacterController Register(KinematicMover) Register a kinematic mover to the simulation. public void Register(KinematicMover mover) Parameters mover KinematicMover SimulationUpdate() Tick simulation, calculating movements for all KCC Actors. public void SimulationUpdate() Unregister(KinematicCharacterController) Unregister a kinematic character from the simulation. public void Unregister(KinematicCharacterController character) Parameters character KinematicCharacterController Unregister(KinematicMover) Unregister a kinematic mover from the simulation. public void Unregister(KinematicMover mover) Parameters mover KinematicMover Events PostSimulationUpdateEvent This event is fired after the simulation and post-simulation interpolation setup has happened, after all KCC actors. public event Action? PostSimulationUpdateEvent Event Type Action PreSimulationUpdateEvent This event is fired before any simulation or pre-simulation interpolation setup happens, before all KCC actors. public event Action? PreSimulationUpdateEvent Event Type Action SimulationUpdateEvent This event is fired when the simulation happens, before all KCC actors. public event Action? SimulationUpdateEvent Event Type Action See Also GamePlugin"
  },
  "api/KCC.KCCSettings.html": {
    "href": "api/KCC.KCCSettings.html",
    "title": "Class KCCSettings | KCC",
    "summary": "Class KCCSettings Namespace KCC Assembly KCC.CSharp.dll Container for settings related to KCC. public class KCCSettings Inheritance object KCCSettings Fields AutoSimulation Should the system automatically simulate in fixed update? public bool AutoSimulation Field Value bool CharacterInitialCapacity Initial list capacity of kinematic characters, this is not the limit but rather will avoid unnecessary memory allocations. public int CharacterInitialCapacity Field Value int DebugDisplay Determines if KCC should display its debug visuals in editor when a KCC character is selected. public bool DebugDisplay Field Value bool Interpolate Should the system interpolate characters and movers? public bool Interpolate Field Value bool InterpolationMode The update mode where interpolation should happen (if enabled). public InterpolationMode InterpolationMode Field Value InterpolationMode MoverInitialCapacity Initial list capacity of kinematic movers, this is not the limit but rather will avoid unnecessary memory allocations. public int MoverInitialCapacity Field Value int"
  },
  "api/KCC.KinematicBase.html": {
    "href": "api/KCC.KinematicBase.html",
    "title": "Class KinematicBase | KCC",
    "summary": "Class KinematicBase Namespace KCC Assembly KCC.CSharp.dll KCC Simulation driven object. Base class for KCC Actors. public class KinematicBase : RigidBody Inheritance object Object SceneObject Actor RigidBody KinematicBase Derived KinematicCharacterController KinematicMover Constructors KinematicBase() Initializes a new instance of KinematicBase. public KinematicBase() Fields _kccPlugin Reference to KCC plugin. protected KCC _kccPlugin Field Value KCC _transientOrientation The current orientation in simulation. protected Quaternion _transientOrientation Field Value Quaternion _transientPosition The current position in simulation. protected Vector3 _transientPosition Field Value Vector3 Properties InitialOrientation The initial orientation before simulation. [NoSerialize] [HideInEditor] public Quaternion InitialOrientation { get; set; } Property Value Quaternion InitialPosition The initial position before simulation. [NoSerialize] [HideInEditor] public Vector3 InitialPosition { get; set; } Property Value Vector3 TransientOrientation The current orientation in simulation. [NoSerialize] [HideInEditor] public Quaternion TransientOrientation { get; set; } Property Value Quaternion TransientPosition The current position in simulation. [NoSerialize] [HideInEditor] public Vector3 TransientPosition { get; set; } Property Value Vector3 Methods SetOrientation(Quaternion) Set the mover's orientation directly. public void SetOrientation(Quaternion orientation) Parameters orientation Quaternion World space orientation SetPosition(Vector3) Set the mover's position directly. public void SetPosition(Vector3 position) Parameters position Vector3 World space position"
  },
  "api/KCC.KinematicCharacterController.html": {
    "href": "api/KCC.KinematicCharacterController.html",
    "title": "Class KinematicCharacterController | KCC",
    "summary": "Class KinematicCharacterController Namespace KCC Assembly KCC.CSharp.dll KCC Simulation driven character controller object. [ActorContextMenu(\"New/Physics/Kinematic Character Controller\")] [ActorToolbox(\"Physics\")] public class KinematicCharacterController : KinematicBase Inheritance object Object SceneObject Actor RigidBody KinematicBase KinematicCharacterController Inherited Members KinematicBase.InitialPosition KinematicBase.InitialOrientation KinematicBase.TransientPosition KinematicBase._transientPosition KinematicBase.TransientOrientation KinematicBase._transientOrientation KinematicBase._kccPlugin KinematicBase.SetPosition(Vector3) KinematicBase.SetOrientation(Quaternion) Properties AllowStairStepping Determines if stair stepping is allowed at all. [EditorDisplay(\"Stairstepping\", null)] [EditorOrder(114)] public bool AllowStairStepping { get; set; } Property Value bool AttachedRigidBody The RigidBody we are attached to. [NoSerialize] [HideInEditor] public RigidBody? AttachedRigidBody { get; } Property Value RigidBody BoxExtents Box extents of the character (only applicable when ColliderType is Box). [NoSerialize] [HideInEditor] public Vector3 BoxExtents { get; } Property Value Vector3 CanGround Determines if grounding is allowed at all. [NoSerialize] [HideInEditor] public bool CanGround { get; set; } Property Value bool ColliderContactOffset The contact offset value for the automatically generated collider (must be positive). [EditorDisplay(\"Character\", null)] [EditorOrder(101)] public float ColliderContactOffset { get; set; } Property Value float ColliderHalfHeight Half the height of the character. [NoSerialize] [HideInEditor] public float ColliderHalfHeight { get; } Property Value float ColliderHalfRadius Half the radius of the character. [NoSerialize] [HideInEditor] public float ColliderHalfRadius { get; } Property Value float ColliderHeight Height of the character. [EditorDisplay(\"Character\", null)] [EditorOrder(103)] public float ColliderHeight { get; set; } Property Value float ColliderRadius Radius of the character (only applicable when ColliderType is Capsule or Sphere). [EditorDisplay(\"Character\", null)] [EditorOrder(104)] public float ColliderRadius { get; set; } Property Value float ColliderType Collision shape of the character. [EditorDisplay(\"Character\", null)] [EditorOrder(100)] public ColliderType ColliderType { get; set; } Property Value ColliderType CollisionMask The layer mask upon which the character collides with. [EditorDisplay(\"Physics\", null)] [EditorOrder(107)] public LayersMask CollisionMask { get; set; } Property Value LayersMask Controller The character's controller. [NoSerialize] [HideInEditor] public IKinematicCharacter? Controller { get; set; } Property Value IKinematicCharacter FilterCollisions Should we filter collisions? If enabled, the controller will be queried for collision filtering, this is expensive. If disabled, the character will assume everything to be solid, this is less expensive. [EditorDisplay(\"Physics\", null)] [EditorOrder(106)] public bool FilterCollisions { get; set; } Property Value bool GravityEulerNormalized The current gravity as normalized euler angles. [NoSerialize] [HideInEditor] public Vector3 GravityEulerNormalized { get; } Property Value Vector3 GroundNormal Ground normal upon which the character is currently standing on. If not touching ground this will be the opposite of the gravity orientation. [NoSerialize] [HideInEditor] public Vector3 GroundNormal { get; } Property Value Vector3 GroundSnappingDistance Maximum allowed ground snap distance to keep the character grounded while IsGrounded is true. [EditorDisplay(\"Grounding\", null)] [EditorOrder(112)] public float GroundSnappingDistance { get; set; } Property Value float GroundTag Tag used to determine if a collision should be considered valid ground or not. If left empty, all surfaces determined by MaxSlopeAngle are considered valid ground. [EditorDisplay(\"Grounding\", null)] [EditorOrder(110)] public Tag GroundTag { get; set; } Property Value Tag GroundingDistance Distance to surface until the character is considered grounded, KinematicContactOffset is automatically added on this. [EditorDisplay(\"Grounding\", null)] [EditorOrder(111)] public float GroundingDistance { get; set; } Property Value float IsGrounded Is the character currently grounded. [NoSerialize] [HideInEditor] public bool IsGrounded { get; } Property Value bool KinematicAttachedVelocity Velocity only from rigidbody we stood upon. [NoSerialize] [HideInEditor] public Vector3 KinematicAttachedVelocity { get; set; } Property Value Vector3 KinematicContactOffset The contact offset value that determines the distance that the character hovers above any surface (must be positive). [EditorDisplay(\"Character\", null)] [EditorOrder(102)] public float KinematicContactOffset { get; set; } Property Value float KinematicVelocity Velocity, ignoring movements from rigidbody we stood upon. [NoSerialize] [HideInEditor] public Vector3 KinematicVelocity { get; set; } Property Value Vector3 MaxSlopeAngle Maximum allowed ground slope angle, all surfaces below or equal to this limit are considered to be ground. [EditorDisplay(\"Grounding\", null)] [EditorOrder(113)] public float MaxSlopeAngle { get; set; } Property Value float MaxStairStepIterations Maximum amount of stair step iterations per frame. [EditorDisplay(\"Stairstepping\", null)] [EditorOrder(118)] public int MaxStairStepIterations { get; set; } Property Value int MaxUnstuckIterations Maximum allowed amount of unstuck iterations. [EditorDisplay(\"Physics\", null)] [EditorOrder(105)] public int MaxUnstuckIterations { get; set; } Property Value int RigidBodyInteractionMode Determine how to handle dynamic rigidbodies that we have collided with. [EditorDisplay(\"RigidBody interactions\", null)] [EditorOrder(121)] public RigidBodyInteractionMode RigidBodyInteractionMode { get; set; } Property Value RigidBodyInteractionMode RigidBodyMoveMode Determines if the character should move with rigidbodies it is standing on. [EditorDisplay(\"RigidBody interactions\", null)] [EditorOrder(119)] public RigidBodyMoveMode RigidBodyMoveMode { get; set; } Property Value RigidBodyMoveMode SimulatedMass The simulated mass amount for dynamic rigidbody handling. [EditorDisplay(\"RigidBody interactions\", null)] [EditorOrder(122)] public float SimulatedMass { get; set; } Property Value float SlideAccountForPhysicsMaterial If set to true, the character slide will also be affected by the surface's physics material settings. [EditorDisplay(\"Physics\", null)] [EditorOrder(109)] public bool SlideAccountForPhysicsMaterial { get; set; } Property Value bool SlideMultiplier Determines how much the character should slide upon coming to contact with a surface. [EditorDisplay(\"Physics\", null)] [EditorOrder(108)] public float SlideMultiplier { get; set; } Property Value float SolveRigidBodyMovements Determines if the character should solve the movements caused by rigidbodies stood upon. If enabled the character will sweep the movements, this is more expensive and more unstable but will cause less potential collision issues. If disabled the character will not sweep the movements, this is less expensive and more stable but will cause potential collision issues. [EditorDisplay(\"RigidBody interactions\", null)] [EditorOrder(120)] public bool SolveRigidBodyMovements { get; set; } Property Value bool StairStepDistance Maximum allowed stair step height distance. [EditorDisplay(\"Stairstepping\", null)] [EditorOrder(115)] public float StairStepDistance { get; set; } Property Value float StairStepGroundMode Behavior mode for stair stepping. [EditorDisplay(\"Stairstepping\", null)] [EditorOrder(116)] public StairStepGroundMode StairStepGroundMode { get; set; } Property Value StairStepGroundMode StairStepMinimumForwardDistance Minimum distance the character must be able to move forward on a detected step for it to be considered valid. [EditorDisplay(\"Stairstepping\", null)] [EditorOrder(117)] public float StairStepMinimumForwardDistance { get; set; } Property Value float Methods CastCollider(Vector3, Vector3, out RayCastHit, float, uint, bool) Return all colliders collided with by the cast. Will filter if collision filtering is enabled for this character. public bool CastCollider(Vector3 origin, Vector3 direction, out RayCastHit trace, float distance = 3.4028235E+38, uint layerMask = 4294967295, bool hitTriggers = true) Parameters origin Vector3 Point in world space to trace from direction Vector3 trace RayCastHit distance float layerMask uint hitTriggers bool Returns bool True if collided with anything Exceptions NotImplementedException Thrown if unsupported collider type (should never happen) ForceUnground() Force the character to unground. public void ForceUnground() GroundTangent(Vector3) Utility function to project a direction along the ground normal without any lateral movement (accounts for gravity direction) public Vector3 GroundTangent(Vector3 direction) Parameters direction Vector3 Normalized direction Returns Vector3 Projected normalized direction IsNormalStableGround(Vector3) Is the normal vector considered stable ground? public bool IsNormalStableGround(Vector3 normal) Parameters normal Vector3 Returns bool True if stable KinematicUpdate() Calculate movement. This should not ever be called directly. public void KinematicUpdate() OnDisable() Called when actor gets removed from game systems. Occurs on EndPlay event or when actor gets inactivated in hierarchy. Use this event to unregister object from other game system (eg. audio). public override void OnDisable() OnEnable() Called when actor gets added to game systems. Occurs on BeginPlay event or when actor gets activated in hierarchy. Use this event to register object to other game system (eg. audio). public override void OnEnable() OverlapCollider(Vector3, out Collider[], uint, bool, float) Return all colliders we are overlapping with. Will filter if collision filtering is enabled for this character. public bool OverlapCollider(Vector3 origin, out Collider[] colliders, uint layerMask = 4294967295, bool hitTriggers = true, float inflate = 0) Parameters origin Vector3 Point in world space to trace at colliders Collider[] layerMask uint hitTriggers bool inflate float Extra size added to the collider size Returns bool True if overlapped with anything Exceptions NotImplementedException Thrown if unsupported collider type (should never happen) UnstuckSolve(float) Calculates the necessary vector3 to move out of collisions public Vector3 UnstuckSolve(float inflate) Parameters inflate float Extra size added to the collider size Returns Vector3 Amount to push out by so that the character is no longer colliding with anything"
  },
  "api/KCC.KinematicMover.html": {
    "href": "api/KCC.KinematicMover.html",
    "title": "Class KinematicMover | KCC",
    "summary": "Class KinematicMover Namespace KCC Assembly KCC.CSharp.dll KCC Simulation driven object. Utility class that makes kinematic elevators and such faster to program. [ActorContextMenu(\"New/Physics/Kinematic Mover\")] [ActorToolbox(\"Physics\")] public class KinematicMover : KinematicBase Inheritance object Object SceneObject Actor RigidBody KinematicBase KinematicMover Inherited Members KinematicBase.InitialPosition KinematicBase.InitialOrientation KinematicBase.TransientPosition KinematicBase._transientPosition KinematicBase.TransientOrientation KinematicBase._transientOrientation KinematicBase._kccPlugin KinematicBase.SetPosition(Vector3) KinematicBase.SetOrientation(Quaternion) Properties Controller Interface for controlling. [NoSerialize] [HideInEditor] public IKinematicMover? Controller { get; set; } Property Value IKinematicMover KinematicAngularVelocity The current angular velocity in simulation. [NoSerialize] [HideInEditor] public Vector3 KinematicAngularVelocity { get; } Property Value Vector3 KinematicVelocity The current velocity in simulation. [NoSerialize] [HideInEditor] public Vector3 KinematicVelocity { get; } Property Value Vector3 Methods KinematicUpdate() Calculate movement. This should not ever be called directly. public void KinematicUpdate() OnDisable() Called when actor gets removed from game systems. Occurs on EndPlay event or when actor gets inactivated in hierarchy. Use this event to unregister object from other game system (eg. audio). public override void OnDisable() OnEnable() Called when actor gets added to game systems. Occurs on BeginPlay event or when actor gets activated in hierarchy. Use this event to register object to other game system (eg. audio). public override void OnEnable()"
  },
  "api/KCC.RigidBodyInteraction.html": {
    "href": "api/KCC.RigidBodyInteraction.html",
    "title": "Class RigidBodyInteraction | KCC",
    "summary": "Class RigidBodyInteraction Namespace KCC Assembly KCC.CSharp.dll Container for KCC character's RigidBody interactions. public record RigidBodyInteraction Inheritance object RigidBodyInteraction Properties BodyVelocity The speed that the rigidbody had when we collided with it. public Vector3 BodyVelocity { get; set; } Property Value Vector3 CharacterVelocity The speed upon which we collided with. public Vector3 CharacterVelocity { get; set; } Property Value Vector3 Normal The normal of the collision. public Vector3 Normal { get; set; } Property Value Vector3 Point The world position where the collision happened. public Vector3 Point { get; set; } Property Value Vector3 RigidBody The rigidbody hit. public RigidBody RigidBody { get; set; } Property Value RigidBody"
  },
  "api/KCC.RigidBodyInteractionMode.html": {
    "href": "api/KCC.RigidBodyInteractionMode.html",
    "title": "Enum RigidBodyInteractionMode | KCC",
    "summary": "Enum RigidBodyInteractionMode Namespace KCC Assembly KCC.CSharp.dll RigidBody interaction mode for KCC characters. Determines how RigidBodies should interact with the KCC character. public enum RigidBodyInteractionMode Fields Manual = 3 Kinematic interactions are queried through the interface. None = 0 Ignore all rigidbody interactions. PureKinematic = 2 Kinematic interactions with rigidbodies where mass is ignored. SimulateKinematic = 1 Kinematic interactions with rigidbodies where mass matters."
  },
  "api/KCC.RigidBodyMoveMode.html": {
    "href": "api/KCC.RigidBodyMoveMode.html",
    "title": "Enum RigidBodyMoveMode | KCC",
    "summary": "Enum RigidBodyMoveMode Namespace KCC Assembly KCC.CSharp.dll RigidBody moving mode for KCC characters. Determines how the KCC character should move when standing on top of a RigidBody. public enum RigidBodyMoveMode Fields All = 2 Move with all RigidBodies. KinematicMoversOnly = 1 Move only with kinematic mover RigidBodies. None = 0 Disable moving along with RigidBodies."
  },
  "api/KCC.StairStepGroundMode.html": {
    "href": "api/KCC.StairStepGroundMode.html",
    "title": "Enum StairStepGroundMode | KCC",
    "summary": "Enum StairStepGroundMode Namespace KCC Assembly KCC.CSharp.dll Stair stepping mode for KCC characters. Determines what type of stairstepping is allowed. public enum StairStepGroundMode : byte Fields None = 0 Always stairstep. RequireGround = 3 Stairstep only when solid with ground tag is hit. RequireSolid = 1 Stairstep only when solid is hit. RequireStableGround = 4 Stairstep only when stable solid with ground tag is hit. RequireStableSolid = 2 Stairstep only when stable solid is hit."
  },
  "api/KCC.html": {
    "href": "api/KCC.html",
    "title": "Namespace KCC | KCC",
    "summary": "Namespace KCC Classes KCC KCCSettings Container for settings related to KCC. KinematicBase KCC Simulation driven object. Base class for KCC Actors. KinematicCharacterController KCC Simulation driven character controller object. KinematicMover KCC Simulation driven object. Utility class that makes kinematic elevators and such faster to program. RigidBodyInteraction Container for KCC character's RigidBody interactions. Interfaces IKinematicCharacter The required interface for controlling KinematicCharacterController. IKinematicMover The required interface for controlling KinematicMover. Enums ColliderType Collider shape for KCC characters. GroundState Ground state for KCC characters. InterpolationMode KCC Interpolation mode. NOTE: This will be removed in the future once Flax is capable of synching event loop with rendering. (waiting for PR to be accepted). RigidBodyInteractionMode RigidBody interaction mode for KCC characters. Determines how RigidBodies should interact with the KCC character. RigidBodyMoveMode RigidBody moving mode for KCC characters. Determines how the KCC character should move when standing on top of a RigidBody. StairStepGroundMode Stair stepping mode for KCC characters. Determines what type of stairstepping is allowed."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | KCC",
    "summary": "Getting Started To begin, you must first create a KCC Settings file, or use the default file included in the plugin, and add it to the custom settings list with the key KCC Settings This is required for the plugin to function, and contains some overall settings you may want to adjust. After making your kinematic character, you need to make a script that implements the IkinematicCharacterController interface and assign the script to the controller’s Controller property (this can be simply done by just assigning it on the script’s OnEnable, check the KCCExample repository. Tip This method of assigning interfaces means you can hotswap what script is controlling the controller, which may be useful in case you need to swap a character between AI control and Player control. This interface will provide you with the necessary callbacks to alter the behavior during runtime. The controller MUST have an uniform scale of 1, if you wish to to resize the character please update the relevant properties in the KinematicCharacterController. Note This plugin overrides the RigidBody/Transform’s Position and Orientation properties, KinematicBase’s TransientPosition and TransientOrientation properties can be used in place of those. If you wish to forcibly set the position or forcibly set the orientation of the kinematic object (eg. teleporting), you need to use KinematicBase’s functions “SetPosition” and “SetOrientation”. Both KinematicMover and KinematicCharacterController extend from KinematicBase. While the system does execute during a FixedUpdate tick and as such it usually does work with code that also relies on FixedUpdate, it has its own order of internal processing. If you need to somehow exactly step in time with the system outside of the callbacks, you may attach yourself to the exposed Actions in the KCC plugin. See KCC Update loop. Tip The KinematicBase that all KCC Actors inherit from contains some useful information. You may use the InitialPosition and InitialOrientation properties to get the information from before any movement processing has happened, and TransientPosition and TransientOrientation properties to get the information from after any movement processing has happened. Tip The KinematicCharacterController exposes some helper functions for smoother development, most notably: OverlapCollider which can be used to query all overlaps with optional inflation for collider size, CastCollider which can be used to do a standard collider cast. Both of these functions automatically select the correct collider shape that matches the controller’s shape. ForceUnground for jumping and other purposes, IsNormalStableGround for querying if a normal is considered stable with the controller’s settings, and GroundTangent which works similarly to Vector3’s ProjectOnPlane without any of the lateral movement. Additionally for debugging purposes DebugDrawCollider is exposed for quickly drawing a wire shape that matches the controller’s shape. If you use this function you need to wrap it in FLAX_EDITOR define guards."
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | KCC",
    "summary": "Introduction This character controller provides a more classic approach to movement similar that of Valve’s Half-Life or Croteams’s Serious Sam, however replicating this in modern engines can be a bit of a pain as the built in controllers usually fall flat with tiny issues that lessen from the user experience, and full rigidbody controllers can be hard to execute properly. This plugin aims to provide a ready to go package to act as an alternative to the built in character controller found in Flax Engine, based on “Improved Collision detection and Response” by Kasper Fauerby and “Improving the Numerical Robustness of Sphere Swept Collision Detection” by Jeff Linahan. To avoid re-inventing the wheel where possible (and to provide similarity to users) this plugin also pulls in inspiration from the free “Kinematic Character Controller” for Unity by Philippe St-Amand by mirroring the idea of using interfaces to control the KinematicMovers and KinematicCharacterControllers, along side pulling other ideas like using a callback to filter collisions. Note You will need to provide your own logic for actually moving the character, this is simply just a “lower level” alternative to the built in character controller"
  },
  "docs/kccloop.html": {
    "href": "docs/kccloop.html",
    "title": "KCC Update loop | KCC",
    "summary": "KCC Update loop If “Auto Simulation” is enabled in the plugin settings, the following execution order will happen: flowchart LR A[FixedUpdate] --> B(PreSimulationUpdate) --> C(SimulationUpdate) --> D(PostSimulationUpdate) If “Auto simulation” is disabled, it is up to you as the developer to call the above functions manually. During these the following Actions are called (if any attached) from the KCC plugin: PreSimulationUpdateEvent: At the very beginning of the call, before InitialPosition/InitialOrientation are assigned from TransientPosition/TransientOrientation. “SimulationUpdate”: At the very beginning of the call, before all movers and characters are processed. “PostSimulationUpdate”: At the very end of the call, after necessary interpolation info is set up. If “Interpolate” is enabled in the plugin settings, the plugin will automatically interpolate all KCC registered Actors, allowing you to run the game at a lower physics tick rate. If disabled it is up to you as the developer to call the function InterpolationUpdate manually if interpolation is wanted. Caution With the current state of flax, interpolation is disconnect from the actual render event. This will be fixed in the future once the PR gets pulled, but as it stands currently you may experience a 1 frame delay when setting an objects position to a KCC actor's position through a script instead of using the scene hierarchy to do parenting."
  },
  "index.html": {
    "href": "index.html",
    "title": "Kinematic Character Controller | KCC",
    "summary": "Kinematic Character Controller For Flax Engine as a plugin, ideal for retro feel games! Pull requests & suggestions are welcome! Github repository"
  }
}